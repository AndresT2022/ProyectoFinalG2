error=residuals(modelo1)
plot(error, main="Error modelo 1", col="navy")
#Proyecto final
rm(list=ls()) ## Limpiar el entorno de trabajo
setwd("D:/Documents/Andres/ANDES/2.5/ProyectoFinalG2")
#1. Librerias----
#install.packages("lubridate")
require(pacman)
p_load(tidyverse, # manipular/limpiar conjuntos de datos
readxl,    # carga datos de excel
lubridate,  # para fechas
tseries,
astsa,
forecast,
foreign,
quantmod
)
#2. Descargar datos de mi pc ----
## Informacion desde 1-ene-2018 hasta 30--jun-2022
#Precios bolsa energía eléctrica
Pbol_2018 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2018.xlsx")
Pbol_2019 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2019.xlsx")
Pbol_2020 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2020.xlsx")
Pbol_2021 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2021.xlsx")
Pbol_2022 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2022.xlsx")
#3. Unir bases de datos ----
#Precios bolsa energía eléctrica
Pbol <- rbind(Pbol_2018,Pbol_2019,Pbol_2020,Pbol_2021,Pbol_2022)
#4. Limpieza variables ----
#Precios bolsa energía eléctrica
Pbol$Pbol_prom <- rowMeans(Pbol[,2:25])
Pbol <- Pbol[-2:-26]
#5. Exporta base de datos con variables ----
write.csv(Pbol,file = "Pbol.csv",row.names = F)
#6. Importa bases de datos consolidados ----
Pbol <- read_csv("Pbol.csv")
#7. Modelo ARIMA ----
dates <- Pbol$Fecha
Pbol_2 <- Pbol
Pbol_2 <- Pbol_2[-1]
## Create a time series object
Arimar.ts <- ts(Pbol_2,
start = c(2018,1,1),
frequency = 365)
Arimar.ts
print(Arimar.ts)
class(Arimar.ts)
start(Arimar.ts)
end(Arimar.ts)
plot(Arimar.ts,  main="Serie de tiempo", ylab="Precio", col="navy")
#Requiere comprobar estacionalidad
# Prueba con logaritmos
serielog=log(Arimar.ts)
serielog
plot(serielog)
#Prueba de D.F.
adf.test(serielog, alternative = "stationary")
#con la prueba de Dickey-Fuller con p-value de 0.08, se comprueba que no es estacionaria con log
#Prueba de estacionalidad con una diferencia
seriedif=diff(Arimar.ts)
plot(seriedif)
#Prueba de D.F.
adf.test(seriedif,alternative = "stationary")
# con p-value de 0.01, se comprueba que hay estacionalidad
#comprobar autocorrelacion
acf(ts(seriedif, frequency=1))
pacf(ts(seriedif, frequency=1))
#Modelo Arima 1
## 1 autoregresivo, 1 diferencia, 1 media movil
modelo2 <- arima(Arimar.ts,order=c(1,1,7))
summary(modelo2)
#tsdiag(modelo1)
Box.test(residuals(modelo2),type="Ljung-Box")
# con p-vale de 0.7893 mayor a .05 ,se puede afirmar que hay ruido blanco, por consiguiente
# nuestro modelo se ajusta bien.
# Ruido blanco significa que el error
# media igual a cero
# Varianza constante
# No estar serialmente correlacionada
#Mirar errores
error=residuals(modelo2)
plot(error, main="Error modelo 2", col="navy")
#Pronosticos Arima
pronostico_21=forecast::forecast(modelo2,h=30)
pronostico_21
plot(pronostico_21, main="Pronóstico a 30 días", ylab="Precio ($/kWh)", col="navy")
pronostico_22=forecast::forecast(modelo2,h=60)
pronostico_22
plot(pronostico_22, main="Pronóstico a 60 días", ylab="Precio ($/kWh)", col="navy")
pronostico_23=forecast::forecast(modelo2,h=90)
pronostico_23
plot(pronostico_23,  main="Pronóstico a 90 días", ylab="Precio ($/kWh)", col="navy")
#install.packages("recipes")
#install.packages('fastDummies')
#install.packages("popgraph")
#install.packages("lfe")
rm(list=ls())
library(tidyverse)
library(mosaic)
library(recipes)
library(openxlsx)
require("fabricatr")
require("stargazer")
require("boot")
require("fastDummies")
require("dplyr")
library(pacman)
library(lfe)
library(ISLR2)
#Cargar base de datos
setwd("D:/Documents/Andres/ANDES/2.5/ProyectoFinalG2")
Datos <- read_excel("Base_Datos_2018_V6.xlsx")
#Punto 5
#Punto 5.a
#Selección muestra de entrenamiento y prueba
set.seed(10101)
id_train <- sample(1:nrow(Datos),size = 0.7*nrow(Datos), replace = F)
BD_train<- Datos[id_train,]
BD_test <- Datos[-id_train,]
dim(BD_test)
dim(BD_train)
colnames(Datos)
#Modelos entrenamiento
model_1<-lm(P_bolsa~1,data = BD_train)
model_2<-lm(P_bolsa~Por_Aporte_MH,data = BD_train)
model_3<-lm(P_bolsa~Por_Gen_Hidro,data = BD_train)
model_4<-lm(P_bolsa~Por_Gen_Term,data = BD_train)
model_5<-lm(P_bolsa~Disp_Hidro,data = BD_train)
model_6<-lm(P_bolsa~Disp_Term,data = BD_train)
model_7<-lm(P_bolsa~enso,data = BD_train)
model_8<-lm(P_bolsa~P_Henry_Hub,data = BD_train)
model_9<-lm(P_bolsa~Nivel_Embalse,data = BD_train)
#Modelos fuera de muestra
BD_test$model_1<-predict(model_1,newdata = BD_test)
BD_test$model_2<-predict(model_2,newdata = BD_test)
BD_test$model_3<-predict(model_3,newdata = BD_test)
BD_test$model_4<-predict(model_4,newdata = BD_test)
BD_test$model_5<-predict(model_5,newdata = BD_test)
BD_test$model_6<-predict(model_6,newdata = BD_test)
BD_test$model_7<-predict(model_7,newdata = BD_test)
BD_test$model_8<-predict(model_8,newdata = BD_test)
BD_test$model_9<-predict(model_9,newdata = BD_test)
#MSE
mse01<-with(BD_test,mean((P_bolsa-model_1)^2))
mse02<-with(BD_test,mean((P_bolsa-model_2)^2))
mse03<-with(BD_test,mean((P_bolsa-model_3)^2))
mse04<-with(BD_test,mean((P_bolsa-model_4)^2))
mse05<-with(BD_test,mean((P_bolsa-model_5)^2))
mse06<-with(BD_test,mean((P_bolsa-model_6)^2))
mse07<-with(BD_test,mean((P_bolsa-model_7)^2))
mse08<-with(BD_test,mean((P_bolsa-model_8)^2))
mse09<-with(BD_test,mean((P_bolsa-model_9)^2))
#Grafica MSE
vmse1<-c(mse01,mse02,mse03,mse04,mse05,mse06,mse07,mse08,mse09)
graf2<-ggplot(mapping = aes(x=1:9, y=vmse1))+
geom_line(color="blue")+
xlab("Modelos")+
ylab("MSE")+
ggtitle("Resumen MSE")+
theme(plot.title = element_text(hjust = 0.5))+
scale_x_continuous(breaks = seq(1,9,1))
graf2
#Numeral a:
ujs<-c()
hjs<-c()
alphas <- c()
for (j in 1:nrow(BD_test)) {
uj <- model_4$residual[j]
hj <- lm.influence(model_4)$hat[j]
alpha <- uj/(1-hj)
alphas <- c(alphas, alpha)
ujs <- c(ujs, uj)
hjs <- c(hjs, hj)
}
#BD para analizar leverage
BD_Leverage<-cbind(BD_test,alphas)
y_out_test<-predict(model_4,BD_Leverage)
y_real_test<-BD_Leverage$P_bolsa
ggplot(BD_Leverage, aes(x=1:nrow(BD_Leverage)))+
xlab("Días")+
geom_point(aes(y=y_real_test, color="red"))+
ylab("Precio de bolsa")+
geom_line(aes(y=y_out_test), color="blue")+
theme_classic()+
ggtitle("Predicción precio de bolsa")+
theme(plot.title = element_text(hjust = 0.5))
alpha
alphas
ggplot(BD_test, aes(x=alphas, y=P_bolsa))+
geom_point(color="red")+
theme_classic()+
ggtitle("Leverage Stadistic Modelo 4")+
theme(plot.title = element_text(hjust = 0.5))
Box.test(residuals(modelo2),type="Ljung-Box")
#Proyecto final
rm(list=ls()) ## Limpiar el entorno de trabajo
setwd("D:/Documents/Andres/ANDES/2.5/ProyectoFinalG2")
#1. Librerias----
#install.packages("lubridate")
require(pacman)
p_load(tidyverse, # manipular/limpiar conjuntos de datos
readxl,    # carga datos de excel
lubridate,  # para fechas
tseries,
astsa,
forecast,
foreign,
quantmod
)
#2. Descargar datos de mi pc ----
## Informacion desde 1-ene-2018 hasta 30--jun-2022
#Precios bolsa energía eléctrica
Pbol_2018 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2018.xlsx")
Pbol_2019 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2019.xlsx")
Pbol_2020 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2020.xlsx")
Pbol_2021 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2021.xlsx")
Pbol_2022 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2022.xlsx")
#3. Unir bases de datos ----
#Precios bolsa energía eléctrica
Pbol <- rbind(Pbol_2018,Pbol_2019,Pbol_2020,Pbol_2021,Pbol_2022)
#4. Limpieza variables ----
#Precios bolsa energía eléctrica
Pbol$Pbol_prom <- rowMeans(Pbol[,2:25])
Pbol <- Pbol[-2:-26]
#5. Exporta base de datos con variables ----
write.csv(Pbol,file = "Pbol.csv",row.names = F)
#6. Importa bases de datos consolidados ----
Pbol <- read_csv("Pbol.csv")
#7. Modelo ARIMA ----
dates <- Pbol$Fecha
Pbol_2 <- Pbol
Pbol_2 <- Pbol_2[-1]
## Create a time series object
Arimar.ts <- ts(Pbol_2,
start = c(2018,1,1),
frequency = 365)
Arimar.ts
print(Arimar.ts)
class(Arimar.ts)
start(Arimar.ts)
end(Arimar.ts)
plot(Arimar.ts,  main="Serie de tiempo", ylab="Precio", col="navy")
#Requiere comprobar estacionalidad
# Prueba con logaritmos
serielog=log(Arimar.ts)
serielog
plot(serielog)
#Prueba de D.F.
adf.test(serielog, alternative = "stationary")
#con la prueba de Dickey-Fuller con p-value de 0.08, se comprueba que no es estacionaria con log
#Prueba de estacionalidad con una diferencia
seriedif=diff(Arimar.ts)
plot(seriedif)
#Prueba de D.F.
adf.test(seriedif,alternative = "stationary")
# con p-value de 0.01, se comprueba que hay estacionalidad
#comprobar autocorrelacion
acf(ts(seriedif, frequency=1))
pacf(ts(seriedif, frequency=1))
#Modelo Arima 1
## 1 autoregresivo, 1 diferencia, 1 media movil
modelo1 <- arima(Arimar.ts,order=c(1,1,1))
summary(modelo1)
#tsdiag(modelo1)
Box.test(residuals(modelo1),type="Ljung-Box")
# con p-vale de 0.7893 mayor a .05 ,se puede afirmar que hay ruido blanco, por consiguiente
# nuestro modelo se ajusta bien.
# Ruido blanco significa que el error
# media igual a cero
# Varianza constante
# No estar serialmente correlacionada
#Mirar errores
error=residuals(modelo1)
plot(error, main="Error modelo 1", col="navy")
#Pronosticos Arima
pronostico1_1=forecast::forecast(modelo1,h=30)
pronostico1_1
plot(pronostico1_1, main="Pronóstico modelo 1 a 30 días", ylab="Precio ($/kWh)", col="navy")
pronostico1_2=forecast::forecast(modelo1,h=60)
pronostico1_2
plot(pronostico1_2, main="Pronóstico modelo 1 a 60 días", ylab="Precio ($/kWh)", col="navy")
pronostico1_3=forecast::forecast(modelo1,h=90)
pronostico1_3
plot(pronostico1_3,  main="Pronóstico modelo 1 a 90 días", ylab="Precio ($/kWh)", col="navy")
#Modelo Arima 2
## 1 autoregresivo, 1 diferencia, 7 media movil
modelo2 <- arima(Arimar.ts,order=c(1,1,7))
summary(modelo2)
#tsdiag(modelo2)
Box.test(residuals(modelo2),type="Ljung-Box")
# con p-vale de 0.7893 mayor a .05 ,se puede afirmar que hay ruido blanco, por consiguiente
#Mirar errores
error=residuals(modelo2)
plot(error, main="Error modelo 2", col="navy")
#Pronosticos Arima
pronostico2_1=forecast::forecast(modelo2,h=30)
pronostico2_1
plot(pronostico2_1, main="Pronóstico modelo 2 a 30 días", ylab="Precio ($/kWh)", col="navy")
pronostico2_2=forecast::forecast(modelo2,h=60)
pronostico2_2
plot(pronostico2_2, main="Pronóstico modelo 2 a 60 días", ylab="Precio ($/kWh)", col="navy")
pronostico2_3=forecast::forecast(modelo2,h=90)
pronostico2_3
plot(pronostico2_3,  main="Pronóstico modelo 2 a 90 días", ylab="Precio ($/kWh)", col="navy")
#Proyecto final
rm(list=ls()) ## Limpiar el entorno de trabajo
setwd("D:/Documents/Andres/ANDES/2.5/ProyectoFinalG2")
#1. Librerias----
#install.packages("lubridate")
require(pacman)
p_load(tidyverse, # manipular/limpiar conjuntos de datos
readxl,    # carga datos de excel
lubridate,  # para fechas
tseries,
astsa,
forecast,
foreign,
quantmod
)
#2. Descargar datos de mi pc ----
## Informacion desde 1-ene-2018 hasta 30--jun-2022
#Precios bolsa energía eléctrica
Pbol_2018 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2018.xlsx")
Pbol_2019 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2019.xlsx")
Pbol_2020 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2020.xlsx")
Pbol_2021 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2021.xlsx")
Pbol_2022 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2022.xlsx")
#3. Unir bases de datos ----
#Precios bolsa energía eléctrica
Pbol <- rbind(Pbol_2018,Pbol_2019,Pbol_2020,Pbol_2021,Pbol_2022)
#4. Limpieza variables ----
#Precios bolsa energía eléctrica
Pbol$Pbol_prom <- rowMeans(Pbol[,2:25])
Pbol <- Pbol[-2:-26]
#5. Exporta base de datos con variables ----
write.csv(Pbol,file = "Pbol.csv",row.names = F)
#6. Importa bases de datos consolidados ----
Pbol <- read_csv("Pbol.csv")
#7. Modelo ARIMA ----
dates <- Pbol$Fecha
Pbol_2 <- Pbol
Pbol_2 <- Pbol_2[-1]
## Create a time series object
Arimar.ts <- ts(Pbol_2,
start = c(2018,1,1),
frequency = 365)
Arimar.ts
print(Arimar.ts)
class(Arimar.ts)
start(Arimar.ts)
end(Arimar.ts)
plot(Arimar.ts,  main="Serie de tiempo", ylab="Precio", col="navy")
#Requiere comprobar estacionalidad
#Prueba de estacionalidad con una diferencia
seriedif=diff(Arimar.ts)
plot(seriedif)
#Prueba de D.F.
adf.test(seriedif,alternative = "stationary")
# con p-value de 0.01, se comprueba que hay estacionalidad
#comprobar autocorrelacion
acf(ts(seriedif, frequency=1))
pacf(ts(seriedif, frequency=1))
#Modelo Arima 1
## 1 autoregresivo, 1 diferencia, 1 media movil
modelo1 <- arima(Arimar.ts,order=c(1,1,1))
summary(modelo1)
#tsdiag(modelo1)
Box.test(residuals(modelo1),type="Ljung-Box")
# con p-vale de 0.7893 mayor a .05 ,se puede afirmar que hay ruido blanco, por consiguiente
# nuestro modelo se ajusta bien.
# Ruido blanco significa que el error
# media igual a cero
# Varianza constante
# No estar serialmente correlacionada
#Mirar errores
error=residuals(modelo1)
plot(error, main="Error modelo 1", col="navy")
#Pronosticos Arima
pronostico1_1=forecast::forecast(modelo1,h=30)
pronostico1_1
plot(pronostico1_1, main="Pronóstico modelo 1 a 30 días", ylab="Precio ($/kWh)", col="navy")
pronostico1_2=forecast::forecast(modelo1,h=60)
pronostico1_2
plot(pronostico1_2, main="Pronóstico modelo 1 a 60 días", ylab="Precio ($/kWh)", col="navy")
pronostico1_3=forecast::forecast(modelo1,h=90)
pronostico1_3
plot(pronostico1_3,  main="Pronóstico modelo 1 a 90 días", ylab="Precio ($/kWh)", col="navy")
#Modelo Arima 2
## 1 autoregresivo, 1 diferencia, 7 media movil
modelo2 <- arima(Arimar.ts,order=c(1,1,7))
summary(modelo2)
#tsdiag(modelo2)
Box.test(residuals(modelo2),type="Ljung-Box")
# con p-vale de 0.7893 mayor a .05 ,se puede afirmar que hay ruido blanco, por consiguiente
#Mirar errores
error=residuals(modelo2)
plot(error, main="Error modelo 2", col="navy")
#Pronosticos Arima
pronostico2_1=forecast::forecast(modelo2,h=30)
pronostico2_1
plot(pronostico2_1, main="Pronóstico modelo 2 a 30 días", ylab="Precio ($/kWh)", col="navy")
pronostico2_2=forecast::forecast(modelo2,h=60)
pronostico2_2
plot(pronostico2_2, main="Pronóstico modelo 2 a 60 días", ylab="Precio ($/kWh)", col="navy")
pronostico2_3=forecast::forecast(modelo2,h=90)
pronostico2_3
plot(pronostico2_3,  main="Pronóstico modelo 2 a 90 días", ylab="Precio ($/kWh)", col="navy")
acf(ts(seriedif, frequency=1), title="ss")
?acf
#Proyecto final
rm(list=ls()) ## Limpiar el entorno de trabajo
setwd("D:/Documents/Andres/ANDES/2.5/ProyectoFinalG2")
#1. Librerias----
#install.packages("lubridate")
require(pacman)
p_load(tidyverse, # manipular/limpiar conjuntos de datos
readxl,    # carga datos de excel
lubridate,  # para fechas
tseries,
astsa,
forecast,
foreign,
quantmod
)
#2. Descargar datos de mi pc ----
## Informacion desde 1-ene-2018 hasta 30--jun-2022
#Precios bolsa energía eléctrica
Pbol_2018 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2018.xlsx")
Pbol_2019 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2019.xlsx")
Pbol_2020 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2020.xlsx")
Pbol_2021 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2021.xlsx")
Pbol_2022 <- read_excel("Precio_Bolsa_Nacional_($kwh)_2022.xlsx")
#3. Unir bases de datos ----
#Precios bolsa energía eléctrica
Pbol <- rbind(Pbol_2018,Pbol_2019,Pbol_2020,Pbol_2021,Pbol_2022)
#4. Limpieza variables ----
#Precios bolsa energía eléctrica
Pbol$Pbol_prom <- rowMeans(Pbol[,2:25])
Pbol <- Pbol[-2:-26]
#5. Exporta base de datos con variables ----
write.csv(Pbol,file = "Pbol.csv",row.names = F)
#6. Importa bases de datos consolidados ----
Pbol <- read_csv("Pbol.csv")
#7. Modelo ARIMA ----
dates <- Pbol$Fecha
Pbol_2 <- Pbol
Pbol_2 <- Pbol_2[-1]
## Create a time series object
Arimar.ts <- ts(Pbol_2,
start = c(2018,1,1),
frequency = 365)
Arimar.ts
print(Arimar.ts)
class(Arimar.ts)
start(Arimar.ts)
end(Arimar.ts)
plot(Arimar.ts,  main="Serie de tiempo", ylab="Precio", col="navy")
#Requiere comprobar estacionalidad
#Prueba de estacionalidad con una diferencia
seriedif=diff(Arimar.ts)
plot(seriedif)
#Prueba de D.F.
adf.test(seriedif,alternative = "stationary")
# con p-value de 0.01, se comprueba que hay estacionalidad
#comprobar autocorrelacion
acf(ts(seriedif, frequency=1))
pacf(ts(seriedif, frequency=1))
#Modelo Arima 1
## 1 autoregresivo, 1 diferencia, 1 media movil
modelo1 <- arima(Arimar.ts,order=c(1,1,1))
summary(modelo1)
#tsdiag(modelo1)
Box.test(residuals(modelo1),type="Ljung-Box")
# con p-vale de 0.7893 mayor a .05 ,se puede afirmar que hay ruido blanco, por consiguiente
# nuestro modelo se ajusta bien.
# Ruido blanco significa que el error
# media igual a cero
# Varianza constante
# No estar serialmente correlacionada
#Mirar errores
error=residuals(modelo1)
plot(error, main="Error modelo 1", col="navy")
#Pronosticos Arima
pronostico1_1=forecast::forecast(modelo1,h=30)
pronostico1_1
plot(pronostico1_1, main="Pronóstico modelo 1 a 30 días", ylab="Precio ($/kWh)", col="navy")
pronostico1_2=forecast::forecast(modelo1,h=60)
pronostico1_2
plot(pronostico1_2, main="Pronóstico modelo 1 a 60 días", ylab="Precio ($/kWh)", col="navy")
pronostico1_3=forecast::forecast(modelo1,h=90)
pronostico1_3
plot(pronostico1_3,  main="Pronóstico modelo 1 a 90 días", ylab="Precio ($/kWh)", col="navy")
#Modelo Arima 2
## 1 autoregresivo, 1 diferencia, 7 media movil
modelo2 <- arima(Arimar.ts,order=c(1,1,7))
summary(modelo2)
#tsdiag(modelo2)
Box.test(residuals(modelo2),type="Ljung-Box")
# con p-vale de 0.7893 mayor a .05 ,se puede afirmar que hay ruido blanco, por consiguiente
#Mirar errores
error=residuals(modelo2)
plot(error, main="Error modelo 2", col="navy")
#Pronosticos Arima
pronostico2_1=forecast::forecast(modelo2,h=30)
pronostico2_1
plot(pronostico2_1, main="Pronóstico modelo 2 a 30 días", ylab="Precio ($/kWh)", col="navy")
pronostico2_2=forecast::forecast(modelo2,h=60)
pronostico2_2
plot(pronostico2_2, main="Pronóstico modelo 2 a 60 días", ylab="Precio ($/kWh)", col="navy")
pronostico2_3=forecast::forecast(modelo2,h=90)
pronostico2_3
plot(pronostico2_3,  main="Pronóstico modelo 2 a 90 días", ylab="Precio ($/kWh)", col="navy")
